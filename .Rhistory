sam <- donnees[which(donnees$yr_built ==1900),] #sam vérifie
donnees$age <- ifelse(as.numeric(annee) - donnees$yr_built >= 0, as.numeric(annee) - donnees$yr_built, 0)
str(donnees)
summary(donnees)
donnees <- read.csv("kc_house_data.csv")
donnees.init <- read.csv("kc_house_data.csv")
#Prétraitement####
str(donnees)
summary(donnees)
donnees <- donnees[!donnees$bathrooms == 0,]
donnees$bedrooms[which(donnees$bedrooms ==33)] <- as.integer(3)
donnees <- donnees[!donnees$bedrooms == 0,]
donnees$reno <- if(donnees$yr_renovated != 0, as.integer(1))
donnees <- donnees[,-c(1,17)] #enlève ID et zipcode
donnees$date <- substr(donnees$date,1,8)
annee <- substr(donnees$date,1,nchar(donnees$date)-4)
mois <- substr(donnees$date,nchar(donnees$date)-3,nchar(donnees$date)-2)
jour <- substr(donnees$date, nchar(donnees$date)-1, nchar(donnees$date))
donnees$date <- as.POSIXct(paste(annee,mois,jour,sep="-"), format="%Y-%m-%d", tz="UTC")
sam <- donnees[which(donnees$yr_built ==1900),] #sam vérifie
donnees$age <- ifelse(as.numeric(annee) - donnees$yr_built >= 0, as.numeric(annee) - donnees$yr_built, 0)
str(donnees)
summary(donnees)
donnees <- read.csv("kc_house_data.csv")
donnees.init <- read.csv("kc_house_data.csv")
#Prétraitement####
str(donnees)
summary(donnees)
donnees <- donnees[!donnees$bathrooms == 0,]
donnees$bedrooms[which(donnees$bedrooms ==33)] <- as.integer(3)
donnees <- donnees[!donnees$bedrooms == 0,]
donnees$reno <- ifelse(donnees$yr_renovated != 0, as.integer(1), as.integer(0))
donnees <- donnees[,-c(1,17)] #enlève ID et zipcode
donnees$date <- substr(donnees$date,1,8)
annee <- substr(donnees$date,1,nchar(donnees$date)-4)
mois <- substr(donnees$date,nchar(donnees$date)-3,nchar(donnees$date)-2)
jour <- substr(donnees$date, nchar(donnees$date)-1, nchar(donnees$date))
donnees$date <- as.POSIXct(paste(annee,mois,jour,sep="-"), format="%Y-%m-%d", tz="UTC")
sam <- donnees[which(donnees$yr_built ==1900),] #sam vérifie
donnees$age <- ifelse(as.numeric(annee) - donnees$yr_built >= 0, as.numeric(annee) - donnees$yr_built, 0)
str(donnees)
summary(donnees)
donnees <- read.csv("kc_house_data.csv")
donnees.init <- read.csv("kc_house_data.csv")
str(donnees)
summary(donnees)
str(donnees)
donnees <- read.csv("kc_house_data.csv")
donnees.init <- read.csv("kc_house_data.csv")
#Prétraitement####
str(donnees)
summary(donnees)
donnees <- donnees[!donnees$bathrooms == 0,]
donnees$bedrooms[which(donnees$bedrooms ==33)] <- as.integer(3)
donnees <- donnees[!donnees$bedrooms == 0,]
donnees$reno <- ifelse(donnees$yr_renovated != 0, as.integer(1), as.integer(0))
donnees <- donnees[,-c(1,17)] #enlève ID et zipcode
donnees$date <- substr(donnees$date,1,8)
annee <- substr(donnees$date,1,nchar(donnees$date)-4)
mois <- substr(donnees$date,nchar(donnees$date)-3,nchar(donnees$date)-2)
jour <- substr(donnees$date, nchar(donnees$date)-1, nchar(donnees$date))
donnees$date <- as.POSIXct(paste(annee,mois,jour,sep="-"), format="%Y-%m-%d", tz="UTC")
sam <- donnees[which(donnees$yr_built ==1900),] #sam vérifie
donnees$age <- ifelse(as.numeric(annee) - donnees$yr_built >= 0, as.numeric(annee) - donnees$yr_built, 0)
str(donnees)
summary(donnees)
ggplot(donnees, aes(x=age, y=log(price))) + geom_point(alpha=0.4) + theme_bw()
ggplot(donnees, aes(x=factor(reno), y=log(price))) + geom_boxplot() + theme_bw()
ggplot(donnees, aes(x=bedrooms)) + geom_density() + theme_bw()
ggplot(donnees, aes(x=bedrooms)) + geom_histogram() + theme_bw()
ggplot(donnees, aes(x=bedrooms)) + geom_bar() + theme_bw()
#Univariée
ggplot(donnees, aes(x=date)) + geom_density() + theme_bw()
ggplot(donnees, aes(x=price)) + geom_density() + theme_bw()
ggplot(donnees, aes(x=log(price))) + geom_density() + theme_bw()
ggplot(donnees, aes(x=bedrooms)) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=bathrooms)) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=sqft_living)) + geom_density() + theme_bw()
ggplot(donnees, aes(x=sqft_living)) + geom_area() + theme_bw()
ggplot(donnees, aes(x=sqft_living)) + geom_area(stat = "bin") + theme_bw()
ggplot(donnees, aes(x=sqft_lot)) + geom_area(stat = "bin") + theme_bw()
ggplot(donnees[which(donnees$sqft_lot<500000),], aes(x=sqft_lot)) + geom_area(stat = "bin") + theme_bw()
ggplot(donnees[which(donnees$sqft_lot<300000),], aes(x=sqft_lot)) + geom_area(stat = "bin") + theme_bw()
ggplot(donnees, aes(x=floors)) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=waterfront)) + geom_bar() + theme_bw()
summary(donnees$sqft_lot)
summary(donnees$sqft_lot15)
ggplot(donnees, aes(x=factor(waterfront))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(floors))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=bedrooms)) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(bedrooms))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=bathrooms)) + geom_bar() + theme_bw() + coord_flip()
ggplot(donnees, aes(x=factor(bathrooms))) + geom_bar() + theme_bw() + coord_flip()
ggplot(donnees, aes(x=factor(bathrooms))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(waterfront))) + geom_bar() + theme_bw() +
geom_bar(aes(y = ..prop..))+
geom_text(aes( label = scales::percent(..prop..),
y= ..prop.. ), stat= "count", vjust = -.5) +
scale_y_continuous(labels = scales::percent)
ggplot(donnees, aes(x=factor(waterfront))) + theme_bw() +
geom_bar(aes(y = ..prop..)) +
geom_text(aes( label = scales::percent(..prop..),
y= ..prop.. ), stat= "count", vjust = -.5) +
scale_y_continuous(labels = scales::percent)
#2####
library(CASdatasets)
data("freMTPLfreq")
#b
levels(donnees$Brand)
#2####
library(CASdatasets)
data("freMTPLfreq")
donnees <- freMTPLfreq
donnees <- donnees[,-1]
donnees$CarAge[which(donnees$CarAge == 100)] <- NA
str(donnees)
#b
levels(donnees$Brand)
donnees$Brand[donnees$Brand == "Fiat"] <- "autre" #Pk ca marche pas ???
#b
levels(donnees$Brand)
table(donnees$Brand)
donnees <- freMTPLfreq
donnees[donnees$Brand == "Fiat",]$Brand <- "autre" #Pk ca marche pas ???
setwd("/Documents/Université/H20/ASA/Classification non supervisée/Laboratoire sur les distances et k-moyennes")
install.packages("NbClust")
knitr::opts_chunk$set(echo = TRUE)
credit <- read.csv("credit.csv")
colnames(credit) <-
c("id_client",
"balance",
"balance_freq", # Score [0, 1] croissant de fréquence de mise à jour de la balance
"achats_cumul",
"paiement_unique_max",
"achats_finances",
"avance_fonds",
"achats_freq", # Score [0, 1] croissant de fréquence d'achats
"paiement_unique_freq", # Fréquence de paiements fait d'un coup
"achats_finances_freq",
"avance_fonds_freq",
"avance_nb_achats", # Nb d'achats faits sur avance de fonds
"achats_nb",
"limite_credit",
"paiment_cumul",
"paiement_min",
"paiement_pourcent", # % du paiement complet payé
"duree") # Nb de mois depuis ouverture
# Retrait NAs
credit <- credit[!is.na(credit$limite_credit), ]
credit[is.na(credit)] <- 0
str(credit)
data <- data.frame(
indice = c("A", "B", "C", "D", "E"),
groupe = factor(c(1, 2, 3, 4, 5)),
x = c(0, 2, 1, 2, 0),
y = c(60, -50, 0, 60, -65)
)
ggplot(data, aes(x = x, y = y, group = groupe, color = groupe)) +
geom_point() +
geom_text(aes(label = indice), position = position_nudge(x = 0.25)) +
geom_hline(yintercept = 0, linetype = "dashed", size = 0.25) +
geom_vline(xintercept = 0, linetype = "dashed", size = 0.25) +
xlim(-1, 8) +
theme_classic()
dist(data,method = "euclidean")
data <- data.frame(
indice = c("A", "B", "C", "D", "E"),
groupe = factor(c(1, 2, 3, 4, 5)),
x = c(0, 2, 1, 2, 0),
y = c(60, -50, 0, 60, -65)
)
dist(data[,c(3,4)],method = "euclidean")
data <- data.frame(
indice = c("A", "B", "C", "D", "E"),
groupe = factor(c(1, 2, 3, 1, 4)),
x = c(0, 2, 1, 2, 0),
y = c(60, -50, 0, 60, -65)
)
ggplot(data, aes(x = x, y = y, group = groupe, color = groupe)) +
geom_point() +
geom_text(aes(label = indice), position = position_nudge(x = 0.25)) +
geom_hline(yintercept = 0, linetype = "dashed", size = 0.25) +
geom_vline(xintercept = 0, linetype = "dashed", size = 0.25) +
xlim(-1, 8) +
theme_classic()
dist(data[3:4],method="euclidean")
# Calculer la matrice de distance entres chaque point pour les colonnes `x` et `y` seulement
dist(data[,c(3,4)],method = "euclidean")
# Déterminez les deux points les plus près et modifier la colonne `groupe` du jeu de données
# Assigez le même groupe au 2 points et refaites le graphique
#Les plus proches sont 1 et 4, donc D et 1
data <- data.frame(
indice = c("A", "B", "C", "D", "E"),
groupe = factor(c(1, 2, 3, 1, 4)),
x = c(0, 2, 1, 2, 0),
y = c(60, -50, 0, 60, -65)
)
ggplot(data, aes(x = x, y = y, group = groupe, color = groupe)) +
geom_point() +
geom_text(aes(label = indice), position = position_nudge(x = 0.25)) +
geom_hline(yintercept = 0, linetype = "dashed", size = 0.25) +
geom_vline(xintercept = 0, linetype = "dashed", size = 0.25) +
xlim(-1, 8) +
theme_classic()
dist(data[,c(3,4)],method="euclidean")
# Déterminez les 2 points les plus près après ceux trouvez à la question 5
# Assigez le même groupe au 2 points et refaites le graphique
dist(data[,c(3,4)],method="euclidean")
data <- data.frame(
indice = c("A", "B", "C", "D", "E"),
groupe = factor(c(1, 2, 3, 1, 2)),
x = c(0, 2, 1, 2, 0),
y = c(60, -50, 0, 60, -65)
)
ggplot(data, aes(x = x, y = y, group = groupe, color = groupe)) +
geom_point() +
geom_text(aes(label = indice), position = position_nudge(x = 0.25)) +
geom_hline(yintercept = 0, linetype = "dashed", size = 0.25) +
geom_vline(xintercept = 0, linetype = "dashed", size = 0.25) +
xlim(-1, 8) +
theme_classic()
set.seed(666)
credit <- credit[sample(1:nrow(credit), 100),]
credit_clustering <- scale(credit[,-which(colnames(credit) == "id_client")])
distance <- dist(credit_clustering)
# Remplacez AAA et BBB
hc_min <- hclust(distance, method = "single")
hc_max <- hclust(distance)
# Remplacez AAA et BBB
(hc_min <- hclust(distance, method = "single"))
(hc_max <- hclust(distance))
View(hc_max)
par(mfrow = c(2,1))
plot(hc_min)
plot(hc_max)
(mean_single <- mean(hc_min$height))
(mean_max <- mean(hc_max$height))
hc_ward <- hclust(distance,method="ward.D")
plot(hc_ward)
credit <- credit[-which(rownames(credit) == "4982"),]
credit_clustering <- scale(credit[,-which(colnames(credit) == "id_client")])
distance <- dist(credit_clustering)
hc_min <- hclust(d = distance, method = "single")
hc_max <- hclust(d = distance, method = "complete")
hc_ward <- hclust(d = distance, method = "ward.D")
# À FAIRE
cutree_min <- cutree(hc_min,k=2)
cutree_max <- cutree(hc_max,k=2)
cutree_ward <- cutree(hc_ward, k=2)
table(cutree_min)
table(cutree_max)
table(cutree_ward)
hc_max$order
# Ajoutez la colonne `groupe`
credit_clustering$groupe <- cas.numeri(cutree(hc_max,k=2))
# Ajoutez la colonne `groupe`
credit_clustering$groupe <- as.numeri(cutree(hc_max,k=2))
# Ajoutez la colonne `groupe`
credit_clustering$groupe <- as.numeric(cutree(hc_max,k=2))
# Ajoutez la colonne `groupe`
credit$groupe <- as.numeric(cutree(hc_max,k=2))
View(credit)
# Ajoutez la colonne `groupe`
credit$groupe <- as.numeric(cutree(hc_max,k=2))
# Remplacez AAA dans la fonction aggregate pour calculer les
# moyennes et écart-types par groupe
aggregate(as.matrix(credit[,-1]) ~ groupe, FUN=mean)
# Remplacez AAA dans la fonction aggregate pour calculer les
# moyennes et écart-types par groupe
aggregate(as.matrix(credit[,-1]) ~ groupe,credit, FUN=mean)
aggregate(as.matrix(credit[,-1]) ~ groupe,credit, FUN=sd)
?aggregate
?aggregate
# Ajoutez la colonne `groupe`
credit$groupe <- as.numeric(cutree(hc_max,k=2))
# Remplacez AAA dans la fonction aggregate pour calculer les
# moyennes et écart-types par groupe
aggregate(as.matrix(credit[,-1]) ~ credit$groupe, FUN=mean)
aggregate(as.matrix(credit[,-1]) ~ credit$groupe, FUN=sd)
# setup pour ggplot (enlever les commentaires)
credit$groupe <- factor(credit$groupe)
credit.long <- gather(credit, key="variable", value="val", balance:duree)
# Utilisez ggplot pour construire des graphiques de type "boite à moustache" permettant de comparer les deux groupes par variable (enlever les commentaires)
ggplot(credit.long, aes(x=groupe, y=val, color=groupe))+
geom_boxplot()+
facet_wrap(~variable, scales="free_y") +
theme(legend.position = "bottom")
factoextra::fviz_nbclust(x = credit_clustering, FUNcluster = hcut, hc_method = "ward.D", method = "silhouette", k.max = 10)
factoextra::fviz_nbclust(x = credit_clustering, FUNcluster = hcut, hc_method = "ward.D", method = "wss", k.max = 10)
# Ajoutez la colonne `groupe`
credit$groupe <- as.numeric(cutree(hc_max,k=2))
# Remplacez AAA dans la fonction aggregate pour calculer les
# moyennes et écart-types par groupe
aggregate(as.matrix(credit[,-1]) ~ credit$groupe, FUN=mean)
aggregate(as.matrix(credit[,-1]) ~ credit$groupe, FUN=sd)
# setup pour ggplot (enlever les commentaires)
credit$groupe <- factor(credit$groupe)
credit.long <- gather(credit, key="variable", value="val", balance:duree)
# Utilisez ggplot pour construire des graphiques de type "boite à moustache" permettant de comparer les deux groupes par variable (enlever les commentaires)
ggplot(credit.long, aes(x=groupe, y=val, color=groupe))+
geom_boxplot()+
facet_wrap(~variable, scales="free_y") +
theme(legend.position = "bottom")
factoextra::fviz_nbclust(x = credit_clustering, FUNcluster = hcut, hc_method = "ward.D", method = "wss", k.max = 10)
plot(hc_ward)
rect.hclust(hc_ward, k = 4, border = 2:5)
# Ajoutez la colonne `groupe`
type_ward <- cutree(tree=hc_ward, k=4)
credit$groupe <- type_ward
# setup pour ggplot (enlever les commentaires)
credit$groupe <- factor(type_ward)
credit.long <- gather(credit, key="variable", value="val", balance:duree)
# Utilisez ggplot pour construire des graphiques de type "boite à moustache" permettant de comparer les quatre groupes par variable (enlever les commentaires)
ggplot(credit.long, aes(x=groupe, y=val, color=groupe))+
geom_boxplot()+
facet_wrap(~variable, scales="free_y") +
theme(legend.position = "bottom")
#ISLR####
data("USArrests")
str(USAccDeaths)
View(USArrests)
str(USArrests)
summary(USArrests)
?prcomp
pca <- prcomp(USArrests, scale. = T)
View(pca)
biplot(pca,scale = 0)
pca$sdev
#7####
#a
dat <- read.csv2("InsurEconIndices.csv")
setwd("/Documents/Université/H20/ASA/Analyse en composantes principales/Exercices")
setwd("/Documents/Université/H20/ASA/Analyse en composantes principales/Exercices")
#7####
#a
dat <- read.csv2("InsurEconIndices.csv")
str(dat)
library("GGally")
ggpairs(dat[,-1], aes(alpha = 0.4))
plot(dat[,-1])
View(dat)
#2
#a
cor(dat[6:7])
#2
#a
var(dat[6:7])
?eigen
#b
eigen(dat[6:7])
#b
eigen(var(dat[6:7]))
#c
posi <- -eigen(var(dat[6:7]))$vectors
posi
sapply(1:2, function(i) posi[i,1]/sum(posi[1,1],posi[2,1]))
0.6640793 +0.3359207
#c
769.03004 /(769.03004 +4.23715)
#3
library(FactoMineR)
?pca
?PCA
PCA(dat[,-1],scale.unit = T)
pca <- PCA(dat[,-1],scale.unit = T)
pca$var$contrib
pca$var
pca$eig
#4
pca2 <- PCA(dat[,-1], scale.unit = F)
pca2$eig
?map
?PCA
pca$ind$coord
pca$var$coord
?select
?PCA
install.packages("Hmisc")
setwd("/Documents/Université/H20/ASA/Classification non supervisée/Laboratoire sur les distances et k-moyennes")
knitr::opts_chunk$set(echo = TRUE)
liste.paquetage <- c("tidyverse", "ggplot2", "cluster", "lsa", "FactoMineR", "tm", "wordcloud")
# Installation des paquetages sur CRAN (si pas déjà installés)
inst <- liste.paquetage %in% installed.packages()
if(length(liste.paquetage[!inst]) > 0){ install.packages(liste.paquetage[!inst])
}
# Importation des paquetages
require(tidyverse)
require(ggplot2)
library(cluster)
library(FactoMineR)
set.seed(718888)
premiers <- c(1, 2, 3, 5, 7, 11, 13, 17)
dist(premiers, method = "euclidean")
dist(premiers, method = "euclidean", diag = TRUE, upper = TRUE)
## Calculez un indice de similarité à partir des distances euclidiennes.
1/(1 + dist(premiers, method = "euclidean"))
quelques_observations <- rbind(c(0, 1, 0, 2),
c(2, 3, 2, 1),
c(3, 0, 2, 1))
dist(quelques_observations, method = "minkowski", p = 2)
data(flower)
fleurs <- flower
colnames(fleurs) <- c("est_hivernale","aime_ombre", "a_tubercule",  "couleur", "sol", "preference", "hauteur_cm", "dist_plants_cm")
fleurs[1, ]
deux_fleurs <- t(apply(fleurs[1:2,],1, function(x) as.numeric(as.character(x)))) #le 1 veut juste dire les lignes
dist(deux_fleurs, method = "euclidean")
dissim <- daisy(fleurs)
# Remplacez XXX pour répondre à la question 4.
dissim_tubercule <- daisy(fleurs, type = list(asymm=3))
dissim_tubercule
raw_credit <- read.csv("credit.csv")
formatted_credit <- raw_credit[1:500, ]  # Préoccupations mémoire
rm(raw_credit)
colnames(formatted_credit) <-
c("id_client",
"balance",
"balance_freq", # Score [0, 1] croissant de fréquence de mise à jour de la balance
"achats_cumul",
"paiement_unique_max",
"achats_finances",
"avance_fonds",
"achats_freq", # Score [0, 1] croissant de fréquence d'achats
"paiement_unique_freq", # Fréquence de paiements fait d'un coup
"achats_finances_freq",
"avance_fonds_freq",
"avance_nb_achats", # Nb d'achats faits sur avance de fonds
"achats_nb",
"limite_credit",
"paiment_cumul",
"paiement_min",
"paiement_pourcent", # % du paiement complet payé
"duree") # Nb de mois depuis ouverture
# Retrait NAs et identifiant (inutile pour la distance)
formatted_credit <- formatted_credit[,-1]
formatted_credit <- formatted_credit[!is.na(formatted_credit$limite_credit), ]
formatted_credit[is.na(formatted_credit)] <- 0
str(formatted_credit)
credit <- scale(formatted_credit)
K <- 3
centroides <- credit[sample(1:nrow(credit), K), ]
euclidienne <- function(obs1, obs2) {
# Cette fonction prend en argument deux vecteurs numériques et retourne la distance euclidienne entre les deux.
sqrt(sum((obs1-obs2)^2))
}
pp_centroide <- function(obs, centroides) {
# Cette fonction localise le plus près centroide pour une observation.
# On calcule d'abord les distances
distances <- apply(centroides, 1, euclidienne, obs2=obs)
# retourne le plus près centroide pour une observation.
which.min(distances)
}
groupe <- apply(credit, 1, pp_centroide, centroides=centroides)
credit <- cbind(credit, groupe)
# Étape 2
centroides <- aggregate(. ~ groupe, as.data.frame(credit), mean)
# Retirer les mentions de groupe pour refaire la boucle.
credit <- credit[,-18]
centroides <- select(centroides,-c("groupe"))
credit_acp <- PCA(rbind(credit, centroides), scale = FALSE, ncp = 2, graph = FALSE)
composante1 <- credit_acp$ind$coord[,1]
composante2 <- credit_acp$ind$coord[,2]
groupes <- as.factor(c(groupe,rep("Centres",K)))
(groupes <- as.factor(c(groupe,rep("Centres",K))))
ggplot() +
geom_point(aes(composante1, composante2, color = groupes, shape=groupes),alpha=0.7) +
theme_minimal()
ggplot() +
geom_point(aes(composante1, composante2, color = groupes, shape=groupes),alpha=0.7) +
theme_minimal()
?silhouette
?pam
install.packages("leaflet")
donnees <- read.csv("kc_house_data.csv")
donnees.init <- read.csv("kc_house_data.csv")
str(donnees)
summary(donnees)
donnees <- donnees[!donnees$bathrooms == 0,] #10 cas
setwd("/Documents/Université/H20/ASA/TP-Apprentissage")
donnees <- read.csv("kc_house_data.csv")
donnees.init <- read.csv("kc_house_data.csv")
donnees <- donnees[!donnees$bathrooms == 0,] #10 cas
donnees <- donnees[!donnees$bedrooms == 0,] #13 cas
donnees$bedrooms[which(donnees$bedrooms ==33)] <- as.integer(3)
donnees$date <- substr(donnees$date,1,8)
annee <- substr(donnees$date,1,nchar(donnees$date)-4)
mois <- substr(donnees$date,nchar(donnees$date)-3,nchar(donnees$date)-2)
jour <- substr(donnees$date, nchar(donnees$date)-1, nchar(donnees$date))
donnees$date <- as.POSIXct(paste(annee,mois,jour,sep="-"), format="%Y-%m-%d", tz="UTC")
age_reno <- ifelse(donnees$yr_renovated==0, 116, pmax(as.numeric(annee) - donnees$yr_renovated, 0)) #6 données à -1 sinon
library(Hmisc)
donnees$reno <- factor(as.vector(cut2(age_reno, c(0, 10, 115)))) # (on peut rajouter des intervalles)
levels(donnees$reno) <- c("10 ans et moins", "10 ans et plus", "Jamais rénové")
donnees$age <- ifelse(as.numeric(annee) - donnees$yr_built >= 0, as.numeric(annee) - donnees$yr_built, 0) #cap à 115
#### ANALYSE EXPLORATOIRE DES DONNEES - Univariée ####
library(ggplot2)
ggplot(donnees, aes(x=factor(round(bathrooms)), y=log(price), col = bedrooms)) + geom_boxplot() + theme_bw()
ggplot(donnees, aes(x=factor(round(bathrooms)), y=log(price), color = bedrooms)) + geom_boxplot() + theme_bw()
ggplot(donnees, aes(x=factor(round(bathrooms)), y=log(price), color = factor(bedrooms))) + geom_boxplot() + theme_bw()
library(ggplot2)
par(mfrow = c(2,2))
ggplot(donnees, aes(x=factor(bedrooms))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(floor(bathrooms)))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(floors))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(waterfront))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(view))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(condition))) + geom_bar() + theme_bw()
ggplot(donnees, aes(x=factor(grade))) + geom_bar() + theme_bw()
par(mfrow = c(1,2))
ggplot(donnees, aes(x=factor(bedrooms), y=log(price))) + geom_boxplot() + theme_bw()
ggplot(donnees, aes(x=factor(floor(bathrooms)), y=log(price))) + geom_boxplot() + theme_bw()
install.packages("gridExtra")
30/200
